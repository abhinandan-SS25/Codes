---
author: "Abhinandan Saha"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
                      warning = FALSE, error = TRUE,
                      fig.height = 3)
library(tidyverse)
library(lubridate)
source("../../scripts/viridis.R")
```

## Assignment 6

#### Due Sunday, March 26, 11:59 PM CT

### Preliminaries

- Directories
    - COURSE/homework/
    - COURSE/homework/hw06/
    - COURSE/data/
    - COURSE/scripts/
- Files
  - COURSE/homework/hw06/hw06.Rmd
  - COURSE/data/exoplanets-clean-through-2022.csv
  - COURSE/data/wordle.csv
  - COURSE/scripts/viridis.R

### Aims

- Practice strings and regular expressions


### Problems

Problems 1--4 are based on a data frame with the names of built-in R colors.
  
```{r}
df_colors = tibble(color = colors()) %>% 
  mutate(index = row_number(), .before = color)
```

  1. Create a data frame with the names of all colors whose names are exactly 7 characters long. Print a summary of this data frame with the number of colors and the first and last alphabetically in the list.
  
```{r}
df_colors_f = df_colors %>%
  filter(str_length(color) == 7) %>%
  arrange(color)

first_word = df_colors_f%>%
  slice_max(n=1, order_by=color)
last_word = df_colors_f%>%
  slice_max(n=1, order_by=desc(color))
df_length = df_colors_f %>%
  summarise(n=n())

required_df = data.frame(df_length, first_word, last_word) %>%
  rename("Number of colors"=n, "First Word"=color, "Last word"=color.1) %>%
  select(-index, -index.1) %>%
  print()
```


  2. How many of the previous color names contain no digits? Create a second data frame which eliminates the rows from your solution to the previous problem any color names which contain a digit. Print a summary of this data frame with the number of colors and the first and last alphabetically in the list.

```{r}
df_colors_r = df_colors_f%>%
  mutate(contains_digit = str_detect(df_colors_f$color, "[:digit:]")) %>%
  filter(!contains_digit) %>%
  select(-contains_digit)

first_word_1 = df_colors_r%>%
  slice_min(n=1, order_by=color)
last_word_1 = df_colors_r%>%
  slice_min(n=1, order_by=desc(color))
df_length_1 = df_colors_r %>%
  summarise(n=n())

required_df_1 = data.frame(df_length_1, first_word_1, last_word_1) %>%
  rename("Number of colors"=n, "First Word"=color, "Last word"=color.1) %>%
  select(-index, -index.1) %>%
  print()
```





  3. Find all colors which contain consecutive letters "e". Print a summary with a count of how many such colors there are and the first and last alphabetically.
  
```{r}
df_cons = df_colors %>%
  filter(str_detect(df_colors$color,"ee"))

first_word_2 = df_cons%>%
  slice_min(n=1, order_by=color)
last_word_2 = df_cons%>%
  slice_min(n=1, order_by=desc(color))
df_length_2 = df_cons %>%
  summarise(n=n())

required_df_2 = data.frame(df_length_2, first_word_2, last_word_2) %>%
  rename("Number of colors"=n, "First Word"=color, "Last word"=color.1) %>%
  select(-index, -index.1) %>%
  print()
```



  
  
  4. Find all color names which contain any consecutive identical letters. Create a data frame with these colors.
  
- Print the first ten rows of this data frame
- Tabulate how often each letter is used in a consecutive letter pair and print out this table arranged in descending order of the counts.
- Identify the three color names which have a distinct pair of consecutive identical letters. (These are the only color names which use the given letter pair.)
  
```{r}
df_required = df_colors %>%
  filter(str_detect(df_colors$color, "([a-zA-Z])\\1+"))

df_required %>%
  print(n=10)

df_required %>%
  mutate(e = str_extract(df_required$color, "([a-zA-Z])\\1+")) %>%
  group_by(e) %>%
  summarise(count = n()) %>%
  arrange(desc(count))

req_cols = df_required %>%
  mutate(e = str_extract_all(df_required$color, "([a-zA-Z])\\1+"))
req_cols$l = sapply(req_cols$e, FUN=length)
req_cols %>%
  filter(l > 1)
```


> From the table we observe, only deeppink, springgreen, greenyellow/ yellowgreen and their shades specified by different numbers have a distinct pair of consecutive identical characters.

  
  5. Load the exoplanet data set from the file `exoplanets-clean-through-2022.csv`. Create a new data frame by selecting only the columns `id` and `star`. Find and print all rows where the name in `star` does not match the string in `star` treated as a regular expression.
  
- What seems to be the common characteristic of such star names?

After identifying this characteristic, add a column to the `planets` data frame with the name `star_regex` which, when treated as a regular expression, does match the literal star name exactly. Such a regular expression should begin with `^` and end with `$`. Verify that each star name is matched by the regular expression.
  
  
  
```{r}
planets = read_csv("../../data/exoplanets-clean-through-2022.csv")
```
  

```{r}
planets_1 = planets %>%
  select(id, star)
for (i in planets_1$star) {
  reg = str_c("^", i,"$")
  if (!str_detect(i, reg)) {
    print(i)
  }
}
detect_m = function (s) {
  words_s = unlist(str_split(s, "\\+"))
  regex = str_c("^", str_c(words_s, collapse = "\\+"), "$")
  
  return (regex)
}
planets$star_regex = sapply(planets$star, FUN=detect_m)
planets %>%
  mutate(s = str_detect(star, star_regex)) %>%
  filter(s == FALSE)
```

> The common characterisitic for a failing match for a star name is the presence of the "+" character in the name of the star. This is a special character and thus is not matched when the star name is treated as regex.
We need to escape the "+" symbol with a backslash, with "\+". 
As we can observe the last segment returns a tibble with no records, this means that there is no case where the regex fails to match the corresponding star name. Thus the regex now matches the star name exactly.




  6. Most planets have a name equal to the star name followed by a space and a single lower case letter. Identify all planets for which this pattern is not true.
  
- Print the columns `id`, `planet`, `star`, and `year` for all planets in `planets` which do not fit this pattern.
  
- How many of the 5240 exoplanets do not follow the typical convention?
  
  
```{r}
planets %>%
  filter(!str_detect(planet, str_c("^", str_sub(star_regex, 2, -2), "\ [a-z]", "$"))) %>%
  select(id, planet, star, year) %>%
  print(n=48)
```

> Of the 5240 exoplanets, only 48 do not follow this typical convention.


  7. For the planets whose names **do match** the pattern from the previous problem, create a table which counts the frequency of the last lower case letters in the planet name. Display this data with an effective graph.
  
  
  
```{r}
lc = planets %>%
  filter(str_detect(planet, str_c("^", str_sub(star_regex, 2, -2), "\ [a-z]", "$")))
lc["l"] = str_sub(lc$planet, -1, -1)

lc = lc %>%
  group_by(l) %>%
  summarise(n=n())
ggplot(lc, aes(x=l, y=n))+
  geom_col() +
  xlab("Last small letter") +
  ylab("Frequency of occurance") + 
  ggtitle("Frequency of occurance of last small letter in planet names")
```




  8. The file `wordle_data.csv` contains the original solution list to the game Wordle.
In the game, players attempt to identify a secret five-letter word by guessing a word and using the color-coded information returned.
A green letter from the guess is in the correct location in the secret word.
A yellow letter from the guess is in the secret word, but is not in the correct location.
A gray letter is not in the word (unless a guess contains multiple copis of the same letter and at least one letter is colored and another is gray).

In a puzzle, the guess information is return for these first two guesses.

- SLATE returns the pattern Gray, Gray, Gray, Yellow, Gray
- COUNT returns the pattern Yellow, Green, Gray, Gray, Yellow

*(Note that the words in the data base have all lower case letters.)*

Find all possible solutions in `wrdl` which are consistent with the information given.

*Hint: you may find it easiest to pipe the word list through multiple `filter()` commands instead of trying to create a single regular expression which only matches all possible solutions. For example, you know the secret word contains at least one `T` and this letter is not in the 4th or 5th positions, at least one `C` which is not the first letter, and that the second letter is an `O`. You also know several letters which are not contained in the secret word.*

```{r}
wrdl = read_csv("../../data/wordle_data.csv") %>% 
  filter(solution == TRUE) %>% 
  select(word)
```

```{r}
wrdl = wrdl %>%
  filter(str_detect(wrdl$word, "^(?!c).+$")) 
wrdl = wrdl %>%
  filter(str_detect(wrdl$word, "^.o...$"))
wrdl = wrdl %>%
  filter(str_detect(wrdl$word, "^(?!.*t.$|.*t$).*$"))
wrdl = wrdl %>%
  filter(str_detect(wrdl$word, "^[^slauen]*$"))
wrdl = wrdl %>%
  filter(str_detect(wrdl$word, "^(?=.*c)(?=.*t).*$"))
wrdl
```




